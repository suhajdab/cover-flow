<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Book Cover Flow</title>
  <style>
    body {
      background: #111;
    }

    #floating-card {
      position: fixed;
      bottom: 32px;
      left: 32px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 4px 16px rgba(0, 0, 0, 0.2);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 24px 32px;
      min-width: 260px;
      max-width: 380px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      transition: transform 0.5s ease-in-out;
    }

    #floating-card.hidden {
      transform: translateY(calc(100% + 50px));
    }

    #channel-title {
      font-weight: 600;
      font-size: 1.3em;
      color: #fff;
      line-height: 1.3;
    }

    #book-count {
      color: #ccc;
      font-size: 1.1em;
      font-weight: 500;
    }

    #progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
      overflow: hidden;
      display: block;
    }

    #progress-bar-inner {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #4caf50, #66bb6a);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    #progress-text {
      font-size: 1em;
      color: #bbb;
      font-weight: 500;
      display: block;
    }

    /* Cover flow grid styles */
    #cover-flow {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      width: 100vw;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
      pointer-events: none;
      will-change: transform;
      /* For smooth animation */
    }

    .cover-column {
      width: 240px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .book-cover {
      width: 240px;
      height: auto;
      object-fit: contain;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      background: #f8f8f8;
      display: block;
    }

    .cover-tile {
      width: 90px;
      height: 135px;
      background: #222;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.18);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.15s;
      cursor: pointer;
      position: relative;
    }

    .cover-tile img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      background: #333;
    }
  </style>
</head>

<body>
  <div id="cover-flow"></div>

  <!-- Floating card container -->
  <div id="floating-card">
    <div id="channel-title"></div>
    <div id="book-count"></div>
    <div id="progress-bar">
      <div id="progress-bar-inner"></div>
    </div>
    <div id="progress-text"></div>
  </div>
  <script>
    // Global variables
    let bookData = null;
    let channel = null;
    let books = [];

    // Fetch book data from API
    async function fetchBookData() {
      try {
        const response = await fetch('/api/goodreads?userId=18906657&shelf=read');
        if (!response.ok) {
          if (response.status === 401) {
            throw new Error('Authentication failed - the server rejected the request');
          } else if (response.status === 403) {
            throw new Error('Access forbidden - check API permissions');
          } else if (response.status >= 500) {
            throw new Error('Server error - please try again later');
          } else {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
        }
        return await response.json();
      } catch (error) {
        console.error('Failed to fetch book data:', error);
        throw error;
      }
    }

    // Initialize the application
    async function initializeApp() {
      try {
        progressBarInner.style.width = '0';
        progressText.textContent = 'Fetching book data...';

        bookData = await fetchBookData();
        books = Array.isArray(bookData.items) ? bookData.items : [];

        // Set channel title
        document.getElementById('channel-title').textContent = `${bookData.userId}'s ${bookData.shelf} books`;
        // Set book count
        const bookCount = bookData.total || books.length;
        document.getElementById('book-count').textContent = `Books: ${bookCount}`;

        // Sort books by date_added in descending order
        books.sort((a, b) => {
          const dateAString = a.date_added;
          const dateBString = b.date_added;

          // Handle cases where dates might be missing or invalid
          if (!dateAString && !dateBString) return 0;
          if (!dateAString) return 1;
          if (!dateBString) return -1;

          try {
            const dateA = new Date(dateAString);
            const dateB = new Date(dateBString);

            if (isNaN(dateA.getTime()) && isNaN(dateB.getTime())) return 0;
            if (isNaN(dateA.getTime())) return 1;
            if (isNaN(dateB.getTime())) return -1;

            return dateB - dateA;
          } catch (e) {
            console.warn("Error parsing date for sorting:", a.title, dateAString, b.title, dateBString, e);
            if (!dateAString && !dateBString) return 0;
            if (!dateAString) return 1;
            if (!dateBString) return -1;
            return 0;
          }
        });

        // Start building the wall
        buildWall();
      } catch (error) {
        // More specific error messages
        let errorMessage = 'Failed to load book data.';
        if (error.message.includes('Authentication failed')) {
          errorMessage = 'API authentication failed. Server needs to be updated.';
        } else if (error.message.includes('fetch')) {
          errorMessage = 'Network error. Check your connection and try again.';
        }

        progressText.textContent = errorMessage + location.href;
        progressBarInner.style.width = '0%';
        console.error('Initialization failed:', error);

        // Show the card permanently on error so user can see the message
        document.getElementById('floating-card').classList.remove('hidden');
      }
    }

    // --- Sliding wall of book covers ---
    const coverFlow = document.getElementById('cover-flow');
    const progressBar = document.getElementById('progress-bar');
    const progressBarInner = document.getElementById('progress-bar-inner');
    const progressText = document.getElementById('progress-text');

    function preloadImages(books, onProgress, onComplete) {
      let loaded = 0;
      let failed = 0;
      const images = [];
      const total = books.length;
      if (total === 0) {
        onProgress(0, 0, 0);
        onComplete([]);
        return;
      }
      books.forEach((book, idx) => {
        const imgSrc = book.image_url || '';
        if (!imgSrc) {
          loaded++;
          onProgress(loaded, failed, total);
          images[idx] = null;
          if (loaded + failed === total) onComplete(images);
          return;
        }
        const img = new window.Image();
        img.src = imgSrc;
        img.onload = function () {
          loaded++;
          images[idx] = img;
          onProgress(loaded, failed, total);
          if (loaded + failed === total) onComplete(images);
        };
        img.onerror = function () {
          failed++;
          images[idx] = null;
          onProgress(loaded, failed, total);
          if (loaded + failed === total) onComplete(images);
        };
      });
    }

    function buildWallWithPreloaded(images) {
      coverFlow.innerHTML = '';
      const { width, height } = getViewportSize();
      const colWidth = 240;
      let numCols = Math.ceil(width / colWidth);

      // Prepare columns
      const columns = Array.from({ length: numCols }, () => {
        return {
          div: document.createElement('div'),
          height: 0 // actual pixel height of images + gaps
        };
      });
      columns.forEach(col => {
        col.div.className = 'cover-column';
      });

      // Repeat books if needed to fill the screen
      let colIdx = 0;
      let repeats = 0;
      const maxRepeats = 10; // avoid infinite loop
      let filled = false;
      let nextBookIdx = 0; // Track where we left off
      while (!filled && repeats < maxRepeats) {
        for (let b = nextBookIdx; b < books.length; ++b) {
          const img = images[b];
          if (!img) continue;

          // If current column is full (height >= window height), move to next column
          while (colIdx < columns.length && columns[colIdx].height >= height) {
            colIdx++;
          }
          if (colIdx >= columns.length) {
            filled = true;
            nextBookIdx = b; // Save where we stopped
            break;
          }

          // Clone the image if it's a repeat
          const imgNode = repeats === 0 ? img : img.cloneNode(true);
          imgNode.className = 'book-cover';
          imgNode.alt = books[b].title || 'Book cover';
          imgNode.removeAttribute('style');
          imgNode.onload = null;
          imgNode.onerror = null;

          columns[colIdx].div.appendChild(imgNode);
          const scaledHeight = Math.min(img.naturalHeight * (240 / img.naturalWidth), 320);
          columns[colIdx].height += scaledHeight;
        }
        if (!filled) {
          colIdx = 0;
          nextBookIdx = 0;
          repeats++;
        }
      }

      // Add columns to coverFlow
      columns.forEach(col => coverFlow.appendChild(col.div));

      // Start sliding animation after wall is built
      startCoverFlowAnimation(columns, colWidth, height, images, nextBookIdx);
    }

    // Animation state
    let animationFrameId = null;
    let coverFlowOffset = 0;
    let lastTimestamp = null;
    let currentColumns = [];

    function startCoverFlowAnimation(columns, colWidth, height, images, initialNextBookIdx) {
      // Cancel previous animation if any
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
      }
      coverFlowOffset = 0;
      lastTimestamp = null;
      currentColumns = columns;

      // Initialize the next book index from where initial wall building left off
      let nextBookIdx = initialNextBookIdx % books.length;

      function getWallWidth() {
        return currentColumns.length * colWidth;
      }

      function addColumnToRight() {
        let col = {
          div: document.createElement('div'),
          height: 0
        };
        col.div.className = 'cover-column';

        let filled = false;
        let repeats = 0;
        const maxRepeats = 10;
        let b = nextBookIdx;
        while (!filled && repeats < maxRepeats) {
          for (; b < books.length; ++b) {
            const img = images[b];
            if (!img) continue;
            const imgNode = img.cloneNode(true);
            imgNode.className = 'book-cover';
            imgNode.alt = books[b].title || 'Book cover';
            imgNode.removeAttribute('style');
            imgNode.onload = null;
            imgNode.onerror = null;

            col.div.appendChild(imgNode);
            const scaledHeight = Math.min(img.naturalHeight * (240 / img.naturalWidth), 320);
            col.height += scaledHeight;
            if (col.height >= height) {
              filled = true;
              b++; // move to next book for next column
              break;
            }
          }
          if (!filled) {
            b = 0;
            repeats++;
          }
        }
        // Save the next book index for the next column
        nextBookIdx = b % books.length;
        coverFlow.appendChild(col.div);
        currentColumns.push(col);
      }

      function removeColumnFromLeft() {
        // Remove leftmost column if it's fully out of the screen
        if (currentColumns.length === 0) return;
        const leftEdge = coverFlowOffset + colWidth;
        if (leftEdge <= 0) {
          // Remove first column DOM and from array
          if (coverFlow.firstChild) coverFlow.removeChild(coverFlow.firstChild);
          currentColumns.shift();
          coverFlowOffset += colWidth;
        }
      }

      function animateCoverFlow(ts) {
        if (!lastTimestamp) lastTimestamp = ts;
        const delta = ts - lastTimestamp;
        lastTimestamp = ts;

        // px per second, e.g. 20px/sec
        const speed = 20;
        coverFlowOffset -= (speed * delta) / 1000;

        // When the last column is fully visible, add a new column to the right
        const wallWidth = getWallWidth();
        const { width } = getViewportSize();
        if (wallWidth + coverFlowOffset < width + colWidth) {
          addColumnToRight();
        }

        // Remove columns on the left once fully out of the screen
        removeColumnFromLeft();

        coverFlow.style.transform = `translateX(${coverFlowOffset}px)`;

        animationFrameId = requestAnimationFrame(animateCoverFlow);
      }

      animationFrameId = requestAnimationFrame(animateCoverFlow);
    }

    // Stop animation on resize to avoid glitches, restart after wall is rebuilt
    window.addEventListener('resize', () => {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      buildWall();
    });

    function buildWall() {
      if (!books || books.length === 0) {
        progressText.textContent = 'No books found.';
        return;
      }

      progressBarInner.style.width = '0';
      progressText.textContent = 'Loading covers...';

      preloadImages(books, (loaded, failed, total) => {
        const percent = total ? Math.round((loaded + failed) / total * 100) : 100;
        progressBarInner.style.width = percent + '%';
        progressText.textContent = `Loading covers: ${loaded + failed} / ${total}`;
      }, (images) => {
        buildWallWithPreloaded(images);
        setTimeout(() => {
          setTimeout(() => {
            document.getElementById('floating-card').classList.add('hidden');
          }, 3000);
        }, 500);
      });
    }

    window.addEventListener('resize', buildWall);

    // Get viewport width and height (define this function that was missing)
    function getViewportSize() {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    }

    // Start the application
    initializeApp();
  </script>
</body>

</html>